# Команды git

- `git help` и `git help command` — для вызова встроенной справки по гиту и его конкретным командам
- `git init` — инициализироать пустой репозиторий в текущей рабочей папке
- `git status` — просмотреть текущее состояние (статс) репозитория
- `git add filename/dirname` — добавить (т.е. подготовить) файл/папку для включения в *коммит* в репозитории
- `git add -all` / `git add *`  — подготовить все файлы для включения в коммит
- `git reset filename/dirname` — исключить файл/папку из коммита (изменения не будут добавлены в историю репозитория)
- `git commit -m "описание коммита"` — зафиксировать подготовленные файлы в репозитории («закоммитить»)
- `git diff filename` — посмотреть разницу между текущей версией файла и версией, зафиксированной в последнем коммите. Более сложные случаи (нпример, сравнение двух коммитов) см. в документации `git help diff`
- `git log` — история коммитов с пояснением по каждому из них

- `git log --pretty=format="%h %s" --graph` — наглядно отформатированная история с визуализацией дерева (т.е. векток) репозитория
- `git blame filename` — выдает все строки файла с указанием коммитов и их авторов
- `git branch new_branch source_branch` — сохдать новую ветку с именем `new_branch` на основе указанной ветки с именем `source_branch`
- `git switch branch_name` — переключиться на указанную ветку с именем `branch_name` (она должна существовать)
- `git checkout -b new_branch` — создать и сразу переключитьяс на новую ветку с именем `new_branch`
- `git merge branch_name` — слияние двух веток. По умолчанию указывается имя той ветки, **которую** мы будем присоединять к **текущей**

> например, git merge dev при нахождении на ветке master присоединит ветку dev к ветке master

- `git remote` — обеспечивает локальное взаимодействие с удаленным репозиторием (добавление его для работы в локальной среде, удаление ссылки на него из локальной среды, просмотр состояния удаленного рпозитория). Более подробно см. `git help remote`
- `git remote add <имя> <адрес>` — простой вариант команды, пригодный для повседневных задач

> [!note]
> имя удаленного репозитория используется для удобной ссылки на него в вашей локальной среде; оно может быть любым, но должно быть уникальным в рамках ваших локальных сред
> по договоренности имя основного удаленного репозитория устанавливается как `origin` — источник
> если в команде `git remote add` не указана ветка, то используется основная ветка удаленного репозитория (обычно `master` или `main`)

- `git remote add [-t <ветка>] [-m <мастер-ветка>] [-f] [--tags/--no-tags] [--mirror=<fetch|push>] <имя> <адрес>` — более комплесный вариант использоавния команды с бОльшим числом настроек взаимодейстия с удаленным репозиторием

- `git push <имя/адрес> [<ветка>]` — выгрузить текущее состояние лоального репозитория (т.е. последний сделанный коммит) в указанный удаленный репозиторий
> чаще всего потребуется авторизоваться на соответствующем сервисе и/или использовать учетные данные с этого сервиса при работе с локальным репозиторием
- `git fetch <имя удаленного репозитория>` — получить все коммиты из удаленного репозитория, НО никак не влиять на состояние локального репозитрия
- `git pull <имя удаленного репозитория>` — комбинация `git fetch` и `git merge`, т.е. получение коммитов из удаленного репозитория И одновременное слияние с текущей локальной веткой

- `git clone <адрес (URL)>` — создать копию удаленного репозитория, который находится по указанному адресу, на локальной машине и автоматически переключить созданную копию на основную ветку (`master`/`main` и т.п.). Т.е. получить рабочую локальную копию любого публичного репозитория.

- `git revert <идентификатор коммита>` — откатить изменения (undo, Ctrl+Z и т.п.), внесенные предыдущим коммитом без изменения истории коммитов (создается новый коммит, содержащий обращение изменений отменяемого коммита)
- `git reset` — более мощная версия отката изменений, НО И БОЛЕЕ ОПАСНАЯ. Для повседневных нужд НЕ РЕКОМЕНДУЕТСЯ (но см. `git help reset`, если прижмет). Бывает `--soft` и `--hard`.

# Полезные заметки

## Статусы файлов

- `U` — Unstaged/Untracked, файлы с такой меткой не отслеживаются, изменения в нем не попадут в репозиторий
- `A` - Added / S — Staged, файл с такой меткой добавлен в индекс и будет включен в следуюий коммит
- `M` — Modified, файл, который уже был зафиксирован в репозитории ранее (т.е. включен хотя бы в 1 предыдущий коммит), но был изменен
- `D` — Deleted, файл, который был зафиксирован в одном из предыдущих коммитов, но ыл удален в текущей версии.

> [!note]
> Переименование файла ведет к тому, что старое имя файла поменчается как `D`, а новое — как `U`

## Управление файлаи, которые будут добавлены в репозиторий и/или помечены для добавления

Это делается при помощи файла `.gitignore`

Любые папки, расишрения файлов, конкретные имена файлов, перечисленные в файле `.gitignore`, полностью пропадают из поля зрения репозитория

## Начальная настройка git

- git config --global user.email "you@example.com" — для настройки адреса электронной почты
- git config --global user.name "Ваше Имя" — для настройки имени пользователя/логина

Использование команды без флага `--global` настраивает параметры **только в текущем** репозитории (что удобно, если у вас несколько адресов и/или юзернеймов)

## Области в репозитории 

1. Рабочая директория
2. Область подготовленных файлов (индекс) — то, что пойдет в фиксацию при коммите, содержание будущего коммита
3. HEAD — последний коммит в репозитории, от него рассчитываются другие характеристики состояния коммита (нового). При откате до какого-либо коммита в истории HEAD перемещается на этот коммит. Для нескольких векток репозитория также существуют свои HEADы.

## Ветки

Ветка (branch) — серия последовательно связанных коммитов.

git поддерживает существование в репозитории нескольких векток одновременно. При двух и более ветках хотя бы у 2-х из них должен быть общий источник — коммит, общий для обеих веток.

Активной в одно и то же время может юыть только одна ветка. При переключении веток в рабочей директории заменяется снимок файловой системы, что может привести к потере незафиксированных изменений.

# Идентификация коммитов

Каждый созданный коммит при фиксации *хэшируется*, т.е. слепок файловой системы, включеный в этот коммит, передается в хэш-функцию. Вычисленный хэш является уникальный идентификатором коммита.

Пример такого хэша: `16b5df6c7ae4c592fe76ef3ff7a1a0e58504e3cd`

До версии 2.29 git использовал хэш-функцию SHA-1, с версии 2.29 начат переход на SHA-256.

Во многих случаях достаточно первый 7 знаков хэша для однозначного пределения коммита.

Т.е. `16b5df6` == `16b5df6c7ae4c592fe76ef3ff7a1a0e58504e3cd` при указании в качестве параметров различных команд, выводе сведений о коммите и т.п.

# Сборка мусора

Если репозиторий сложен (много файлов, веток, большая история коммитов), индекс репозитория растет и занимае много места. В таких случаях задействуется встроенный механизм сборки мусора.

Сборка мусора производится автоматически и только для тех коммитов, с которыми не было взаимодействий некоторое время.

Если такие коммиты обнаружены, то к ним применяется механизм замены наиболее старых версий файлов на дельты (см. `git diff`) между ними и текущими версиями файлов.
